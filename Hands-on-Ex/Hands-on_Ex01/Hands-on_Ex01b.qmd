---
title: "Hands-on Excercise 1b"
date: "23/8/25"
date-modified: "last-modified"
format: html
execute: 
  echo: true
  eval: true
  warning: false
  freeze: true
---

# 2 Thematic Mapping and GeoVisualisation with R

using tmap package

```{r}
pacman::p_load(sf, tmap, tidyverse, rvest)
```

```{r}
mpsz <- st_read("data/geospatial/MasterPlan2019SubzoneBoundaryNoSeaKML.kml")
```

```{r}
extract_kml_field <- function(html_text, field_name) {
  if (is.na(html_text) || html_text == "") return(NA_character_)
  
  page <- read_html(html_text)
  rows <- page %>% html_elements("tr")
  
  value <- rows %>%
    keep(~ html_text2(html_element(.x, "th")) == field_name) %>%
    html_element("td") %>%
    html_text2()
  
  if (length(value) == 0) NA_character_ else value
}
```

```{r}
mpsz <- mpsz %>%
  mutate(
    REGION_N = map_chr(Description, extract_kml_field, "REGION_N"),
    PLN_AREA_N = map_chr(Description, extract_kml_field, "PLN_AREA_N"),
    SUBZONE_N = map_chr(Description, extract_kml_field, "SUBZONE_N"),
    SUBZONE_C = map_chr(Description, extract_kml_field, "SUBZONE_C")
  ) %>%
  select(-Name, -Description) %>%
  relocate(geometry, .after = last_col())
```

```{r}
mpsz
```

Notice that only the first ten records will be displayed. Do you know why?

Its a preview of the data

### **2.3.3 Importing Attribute Data into R**

Next, we will import *respopagesextod2024.csv* file into RS

```{r}

popdata <- read_csv("data/aspatial/respopagesextod2024.csv")

```

### **2.3.4 Data Preparation**

Before a thematic map can be prepared, we need to prepare a data table with year 2020 values. The data table should include the variables PA, SZ, YOUNG, ECONOMY ACTIVE, AGED, TOTAL, DEPENDENCY.

-   YOUNG: age group 0 to 4 until age groyup 20 to 24,

-   ECONOMY ACTIVE: age group 25-29 until age group 60-64,

-   AGED: age group 65 and above,

-   TOTAL: all age group, and

-   DEPENDENCY: the ratio between young and aged against economy active group

#### 2.3.4.1 Data wrangling

The following data wrangling and transformation functions will be used:

-   *pivot_wider()* of **tidyr** package, and

-   *mutate()*, *filter()*, *group_by()* and *select()* of **dplyr** package

```{r}
popdata2024 <- popdata %>%
  group_by(PA, SZ, AG) %>%
  summarise(`POP` = sum(`Pop`)) %>%
  ungroup()%>%
  pivot_wider(names_from=AG, 
              values_from=POP) %>%
  mutate(YOUNG = rowSums(.[3:6])
         +rowSums(.[12])) %>%
mutate(`ECONOMY ACTIVE` = rowSums(.[7:11])+
rowSums(.[13:15]))%>%
mutate(`AGED`=rowSums(.[16:21])) %>%
mutate(`TOTAL`=rowSums(.[3:21])) %>%  
mutate(`DEPENDENCY` = (`YOUNG` + `AGED`)
/`ECONOMY ACTIVE`) %>%
  select(`PA`, `SZ`, `YOUNG`, 
       `ECONOMY ACTIVE`, `AGED`, 
       `TOTAL`, `DEPENDENCY`)

```

#### 2.3.4.2 Joining the attribute data and geospatial data

Before we can perform the georelational join, one extra step is required to convert the values in PA and SZ fields to uppercase. This is because the values of PA and SZ fields are made up of upper- and lowercase. On the other, hand the SUBZONE_N and PLN_AREA_N are in uppercase.

```{r}
popdata2024 <- popdata2024 %>%
  mutate_at(.vars = vars(PA, SZ), 
          .funs = list(toupper)) %>%
  filter(`ECONOMY ACTIVE` > 0)
```

Next, *left_join()* of **dplyr** is used to join the geographical data and attribute table using planning subzone name e.g. *SUBZONE_N* and *SZ* as the common identifier.

```{r}
mpsz_pop2024 <- left_join(mpsz, popdata2024,
                          by = c("SUBZONE_N" = "SZ"))
```

Thing to learn from the code chunk above:

-   *left_join()* of **dplyr** package is used with `mpsz` simple feature data frame as the left data table is to ensure that the output will be a simple features data frame.

```{r}
write_rds(mpsz_pop2024, "data/rds/mpsz_pop2024.rds")
```

## **2.4 Choropleth Mapping Geospatial Data Using *tmap***

### **Plotting a choropleth map quickly by using *qtm()***

The easiest and quickest to draw a choropleth map using **tmap** is using *qtm()*. It is concise and provides a good default visualisation in many cases.

The code chunk below will draw a cartographic standard choropleth map as shown below.

```{r}
tmap_mode("plot")
qtm(shp = mpsz_pop2024, 
    fill = "DEPENDENCY")
```

-   **`shp = mpsz_pop2024`** → the geometry + attribute table (planning subzones + population data).

<!-- -->

-   **`fill = "DEPENDENCY"`** → polygons are shaded by the values in the `DEPENDENCY` column.

### **2.4.2 Creating a choropleth map by using *tmap*’s elements**

example:

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile", 
                n = 5,
                values = "brewer.blues"),
              fill.legend = tm_legend(
                title = "Dependency ratio")) +
  tm_title("Distribution of Dependency Ratio by planning subzone") +
  tm_layout(frame = TRUE) +
  tm_borders(fill_alpha = 0.5) +
  tm_compass(type="8star", size = 2) +
  tm_scalebar() +
  tm_grid(alpha =0.2) +
  tm_credits("Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA)\n and Population data from Department of Statistics DOS", 
             position = c("left", "bottom"))
```

#### 2.4.2.1 Drawing a base map

The basic building block of **tmap** is `tm_shape()` followed by one or more layer elemments such as `tm_polygons()`, `tm_symbols()`, `tm_lines()`, `tm_raster()` and `tm_text()`.

In the code chunk below, `tm_shape()` is used to define the input data (i.e *mpsz_pop2024*) and `tm_polygons()` is used to draw the planning subzone polygons

```{r}

tm_shape(mpsz_pop2024) +
  tm_polygons()

```

#### 2.4.2.2 Drawing a choropleth map using `tm_polygons()`

Assign target variable such as *Dependency* to *tm_polygons()*.

```{r}
tm_shape(mpsz_pop2024)+
  tm_polygons(fill = "DEPENDENCY")
```

-   By default, Missing value will be shaded in grey.

#### 2.4.2.3 Drawing a choropleth map using *tm_fill()* and \*tm_border()\*\*

Actually, `tm_polygons()` is a wraper of `tm_fill()` and `tm_border()`. `tm_fill()` shades the polygons by using the default colour scheme and `tm_borders()` adds the borders of the polygon features onto the choropleth map.

The code chunk below draws a choropleth map by using `tm_fill()` alone.

```{r}
tm_shape(mpsz_pop2024)+
  tm_fill("DEPENDENCY")

```

```{r}
tm_shape(mpsz_pop2024)+
  tm_fill("DEPENDENCY") +
  tm_borders()
```

```{r}
tm_shape(mpsz_pop2024)+
  tm_fill("DEPENDENCY") +
  tm_borders(col = "grey60",
             lwd = 0.1,
             lty = "dashed")
```

### **2.4.3 Data classification methods of tmap**

Most choropleth maps employ some methods of data classification. The point of classification is to take a large number of observations and group them into data ranges or classes.

**tmap** provides a total ten data classification methods, namely: *fixed*, *sd*, *equal*, *pretty* (default), *quantile*, *kmeans*, *hclust*, *bclust*, *fisher*, and *jenks*.

To define a data classification method, the *style* argument of *tm_fill()* or *tm_polygons()* will be used.

#### 2.4.3.1 Plotting choropleth maps with built-in classification methods

The code chunk below shows a quantile data classification that used 5 classes.

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                n = 5)) +
  tm_borders(fill_alpha = 0.5)
```

```{r}

tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "equal",
                n = 5)) +
  tm_borders(fill_alpha = 0.5)
```

Compare **classification methods** (same n = 5)

```{r}
library(tmap); tmap_mode("plot")

make_map <- function(method, n = 5, ttl = NULL) {
  tm_shape(mpsz_pop2024) +
    tm_polygons("DEPENDENCY",
                style = method, n = n, palette = "Blues",
                title = "Dependency",
                colorNA = "grey90", textNA = "Missing", alpha = 0.9) +
    tm_borders(col = "grey40", lwd = 0.4) +
    tm_layout(title = if (is.null(ttl)) paste0(toupper(method), " (n=", n, ")") else ttl,
              legend.outside = TRUE, frame = TRUE)
}

methods <- c("equal","quantile","fisher","kmeans","headtails","pretty")
maps_methods <- lapply(methods, make_map, n = 5)
do.call(tmap_arrange, c(maps_methods, list(ncol = 3)))

```

Same method, **different numbers of classes** (2, 6, 10, 20)

```{r}
ns <- c(2,6,10,20)
maps_n <- lapply(ns, function(k) make_map("quantile", n = k, ttl = paste0("Quantile (n=", k, ")")))
do.call(tmap_arrange, c(maps_n, list(ncol = 2)))

```

### Across methods (n = 5)

-   **Quantile** — Visually balanced map (each class ≈ same number of subzones). Can split very similar values across class boundaries.
-   **Equal** — Same-width ranges; if data are skewed, most areas pile into the lowest class → map looks pale with a few dark outliers.
-   **Fisher/Jenks** (`"fisher"`) — “Natural breaks”; emphasizes clusters and gaps—great for skewed data.
-   **k-means** — Clustering on values; often similar to Jenks but can vary slightly run-to-run.
-   **Head/Tails** — Tailored for heavy right tails—good at highlighting a few extreme areas.
-   **Pretty** — Round-number breaks (human-friendly), not data-optimized.

#### Same method, varying n

-   **n = 2** — Very coarse—clear story, low nuance.
-   **n = 6–10** — Sweet spot—readable and informative without noise.
-   **n = 20** — Patchy/noisy; legend hard to read; tiny color steps are indistinguishable in print.

#### 2.4.3.2 Plotting choropleth map with custome break

For all the built-in styles, the category breaks are computed internally. In order to override these defaults, the breakpoints can be set explicitly by means of the `breaks` argument to the `tm_scale_intervals()`. It is important to note that, in **tmap** the breaks include a minimum and maximum. As a result, in order to end up with n categories, n+1 elements must be specified in the `breaks` option (the values must be in increasing order).

Before we get started, it is always a good practice to get some descriptive statistics on the variable before setting the break points. Code chunk below will be used to compute and display the descriptive statistics of *DEPENDENCY* field.

```{r}
summary(mpsz_pop2024$DEPENDENCY)
```

With reference to the results above, we set break point at 0.60, 0.70, 0.80, and 0.90. In addition, we also need to include a minimum and maximum, which we set at 0 and 100. Our `breaks` vector is thus c(0, 0.60, 0.70, 0.80, 0.90, 1.00)

Now, we will plot the choropleth map by using the code chunk below.

```{r}
tm_shape(mpsz_pop2024)+
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                breaks = c(0, 0.60, 0.70, 0.80, 0.90, 1.00))) +
  tm_borders(fill_alpha = 0.5)
```

### **2.4.4 Colour Scheme**

**tmap** supports colour ramps either defined by the user or a set of predefined colour ramps from the **RColorBrewer** package.

#### 2.4.4.1 Using ColourBrewer palette

To change the colour, we assign the preferred colour to *palette* argument of *values* as shown in the code chunk below.

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                n = 5,
                values = "brewer.greens")) +
  tm_borders(fill_alpha = 0.5)
```

Opposite

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                n = 5,
                values = "-brewer.greens")) +
  tm_borders(fill_alpha = 0.5)
```

#### 2.4.4.2 Cartographic Furniture

`tm_compass()` – Add a north arrow

`tm_scale_bar()` – scale bar,

`tm_grid()` – grid lines

`tm_credit()` – credits

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                n = 5)) +
  tm_borders(fill_alpha = 0.5) +
  tm_compass(type="8star", size = 2) +
  tm_scalebar() +
  tm_grid(lwd = 0.1, alpha = 0.2) +
  tm_credits("Source: data.gov.sg & singstat",
             position = c("left", "bottom"))
```

### **2.4.5 Map Layout**

Map layout refers to the combination of all map ndefinedelements into a cohensive map. It includes the map background, frame, typography, scale, aspect ratio, margins, and more.

We can customize the map layout using the `tm_layout()` function. In this section, we cover the most often used arguments of this function using the dependency choropleth map as example.

#### 2.4.5.1 Map Legend

In **tmap**, several *legend* options are provided to change the placement, format and appearance of the legend.

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                n = 5),
              fill.legend = tm_legend(
                title = "Dependency ratio")) +
  tm_pos_auto_in() +
  tm_borders(fill_alpha = 0.5) +
  tm_compass(type="8star", size = 2) +
  tm_scalebar() +
  tm_grid(lwd = 0.1, alpha = 0.2) +
  tm_credits("Source: data.gov.sg & singstat",
             position = c("left", "bottom"))
```

#### 2.4.5.2 Map style

**tmap** allows a wide variety of layout settings to be changed. They can be called by using *tmap_style()*.

The code chunk below shows the *classic* style is used.

```{r}
tm_shape(mpsz_pop2024) +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile",
                n = 5,
                values = "-brewer.greens")) + 
  tm_borders(fill_alpha = 0.5) + 
  tmap_style("natural")

```

```{r}
tmap_style("white")
```

## **Drawing Small Multiple Choropleth Maps**

**Small multiple maps**, also referred to as **facet maps**, are composed of many maps arrange side-by-side, and sometimes stacked vertically. Small multiple maps enable the visualisation of how spatial relationships change with respect to another variable, such as time.

In **tmap**, small multiple maps can be plotted in three ways:

-   by assigning multiple values to at least one of the asthetic arguments,

-   by creating multiple stand-alone maps with *tmap_arrange()*, and

-   by defining a group-by variable in *tm_facets()*.

### **2.5.1 By assigning multiple values to at least one of the aesthetic arguments**

In this example, small multiple choropleth maps are created by assigning two variables to the visual variable (i.e. fill).

```{r}
tm_shape(mpsz_pop2024) + 
  tm_polygons(
    fill = c("YOUNG", "AGED"),
    fill.legend = 
      tm_legend(position = tm_pos_in(
        "right", "bottom")),
    fill.scale = tm_scale_intervals(
      style = "equal", 
      n = 5,
      values = "brewer.blues")) +
  tm_borders(fill_alpha = 0.5) +
  tmap_style("natural")
```

### **By arrange multiples choropleth maps in a grid layout**

In this example, multiple choropleth maps are created and `tmap_arrnage()` is used to arrnage them in a grid layout.

```{r}
youngmap <- tm_shape(mpsz_pop2024)+ 
  tm_polygons(fill = "YOUNG",
              fill.legend = tm_legend(
                position = tm_pos_in(
                  "right", "bottom"),
                  item.height = 0.8),
              fill.scale = tm_scale_intervals(
                style = "quantile", 
                values = "brewer.blues")) +
  tm_borders(fill_alpha = 0.5) +
  tm_title("Distribution of young population")
                
agedmap <- tm_shape(mpsz_pop2024)+ 
  tm_polygons(fill = "AGED",
              fill.legend = tm_legend(
                position = tm_pos_in(
                  "right", "bottom"),
                item.height = 0.8),
              fill.scale = tm_scale_intervals(
              style = "quantile", 
              values = "brewer.blues")) +
  tm_borders(fill_alpha = 0.5) +
  tm_title("Distribution of aged population")

tmap_arrange(youngmap, agedmap, asp=1, ncol=2)
```

### **2.5.3 By defining a group-by variable in *tm_facets()***

creating a **series of small choropleth maps (facets)**, one for each region

```{r}
tm_shape(mpsz_pop2024) +
  tm_fill(fill = "DEPENDENCY",
          fill.scale = tm_scale_intervals(
            style = "quantile",
            values = "brewer.blues")) + 
  tm_facets(by = "REGION_N",
            nrow = 2, 
            ncols = 3,
            free.coords=TRUE, 
            drop.units=TRUE) +
  tm_layout(legend.show = TRUE,
            title.position = c("center", "center"), 
            title.size = 20) +
  tm_borders(fill_alpha = 0.5)
```

## **2.6 Mappping Spatial Object Meeting a Selection Criterion**

Instead of creating small multiple choropleth map, you can also use `filter()` of **dplyr** package to select geographical area of interest and plot a choropleth map focus only on the selected region.

```{r}
mpsz_pop2024 %>%
  filter(REGION_N == "CENTRAL REGION") %>%
  tm_shape() +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile", 
                values = "brewer.greens"),
              fill.legend = tm_legend()) +
  tm_borders(fill_alpha = 0.5)
```

## **Complementing Thematic Map with Statistical Chart**

With tmap, statistical chart and be incorporate into the map visualisation by using `fill.chat` argument of map layers and [**legend chart**](https://r-tmap.github.io/tmap/reference/tm_chart.html) feature as shown in the code chunk below.

```{r}
mpsz_pop2024 %>%
  filter(REGION_N == "CENTRAL REGION") %>%
  tm_shape() +
  tm_polygons(fill = "DEPENDENCY",
              fill.scale = tm_scale_intervals(
                style = "quantile", 
                values = "brewer.greens"),
              fill.legend = tm_legend(),
              fill.chart = tm_chart_box()) +
  tm_borders() +
  tm_layout(asp = 0.8)
```

In the code chunk below, We improve the visual representation further by highlighting and lebaling the outliers on the choropleth map.

```{r}
mpsz_selected <- mpsz_pop2024 %>%
  filter(REGION_N == "CENTRAL REGION")

stats <- boxplot.stats(mpsz_selected$DEPENDENCY)

outlier_vals <- stats$out

outlier_sf <- mpsz_selected[mpsz_selected$DEPENDENCY %in% outlier_vals, ]

tm_shape(mpsz_selected) +
  tm_polygons(fill = "DEPENDENCY",
          fill.scale = tm_scale_intervals(
            style = "quantile", 
            values = "brewer.blues"),
          fill.legend = tm_legend(),
          fill.chart = tm_chart_box()) +
  tm_borders(fill_alpha = 0.5) +
tm_shape(outlier_sf) +
  tm_borders(col = "red", lwd = 2) +
  tm_text("SUBZONE_N", col = "red", size = 0.7) +
  tm_layout(asp = 0.8)
```

## **Creating Interactive Map**

Interactive maps let users actively explore and interact with the data they display. Unlike static maps, you can zoom in and out, pan across areas, click on locations for more information, and even work with data overlays or visualizations—making the experience more dynamic and informative. One of the great things about tmap is that it lets you switch easily between static and interactive maps using `tmap_mode()`, so you can choose the view that best suits your analysis.

By modifying the code chunk in sub-section 2.6, the code chunks below build an interactive map using

```{r}
region_selected <- mpsz_pop2024 %>%
  filter(REGION_N == "CENTRAL REGION")
region_bbox <- st_bbox(region_selected)

stats <- boxplot.stats(region_selected$DEPENDENCY)
outlier_vals <- stats$out
outlier_sf <- region_selected[region_selected$DEPENDENCY %in% outlier_vals, ]

tmap_mode("view")
tm_shape(region_selected, 
         bbox = region_bbox) +
  tm_fill("DEPENDENCY",
          id = "SUBZONE_N",
          popup.vars = c(
            "Name" = "SUBZONE_N", 
            "Dependency" = "DEPENDENCY")) +
  tm_borders() +
  tm_shape(outlier_sf) +
  tm_borders(col = "red", lwd = 2)
```

```{r}
tmap_mode("plot")
```

To `set_zoom_limits` argument can be used to limit the map extend users can zooming in and out of the map areas as shown below.

```{r}
region_selected <- mpsz_pop2024 %>%
  filter(REGION_N == "CENTRAL REGION")
region_bbox <- st_bbox(region_selected)

stats <- boxplot.stats(region_selected$DEPENDENCY)
outlier_vals <- stats$out
outlier_sf <- region_selected[region_selected$DEPENDENCY %in% outlier_vals, ]

tmap_mode("view")

tm_shape(region_selected, 
         bbox = region_bbox) +
  tm_fill("DEPENDENCY",
          id = "SUBZONE_N",
          popup.vars = c(
            "Name" = "SUBZONE_N", 
            "Dependency" = "DEPENDENCY")) +
  tm_borders() +
  tm_shape(outlier_sf) +
  tm_borders(col = "red", lwd = 2) +
  tm_view(set_zoom_limits = c(12,14))
```

```{r}
tmap_mode("plot")
```
